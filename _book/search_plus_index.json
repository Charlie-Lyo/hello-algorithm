{"./":{"url":"./","title":"介绍","keywords":"","body":"小浩算法（持续更新中） 小浩算法目前共完成 105道 高频面试算法题目，全部采用漫画图解的方式。 面向算法小白和初中阶读者。 采用 Java 和 Go，后期会配更多的语言。 现有代码全部在 leetcode 上测试运行，可供系统刷题使用。 该教程目前共有 11w 人阅读 为了大家更好的交流，我创建了万人刷题群 下方扫码回复【刷题】 即可（群里无广告，不套路，不推送） 另外我想说下的是，目前小浩算法的网站已经开源放在了 github 上，如果你看到这里，我想请你帮我给这个项目点一个star，满足一下我的虚荣心。当然，我认为我的文章质量绝对值你一个star。我也会更加努力的进行创作。点击右边的项目源码就可以了。 ☞☞☞ 项目源码 开始学习 阅读指南 1.数组 01.两个数组的交集(350) 02.最长公共前缀(14) 03.买卖股票的最佳时机(122) 04.旋转数组(189) 05.原地删除(27) 06.加一(66) 07.两数之和(1) 2.链表 01.删除链表倒数第N个节点(19) 02.合并两个有序链表(21) 03.环形链表(21) 3.动态规划 01.爬楼梯(70) 02.最大子序和(53) 03.最长上升子序列(300) 04.三角形最小路径和(120) 05.最小路径和(64) 06.打家劫舍(198) 4.字符串 01.反转字符串(344) 02.字符串中的第一个唯一字符(387) 5.二叉树 01.最大深度与DFS(104) 02.层次遍历与BFS(102) 其他：排序专栏 排序算法 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 16:39:44 "},"c99/hello.html":{"url":"c99/hello.html","title":"阅读指南","keywords":"","body":"阅读指南 为什么要做这样的一个算法图解合集 网上的算法教程杂乱且分散，质量层次不齐，浪费了大家大量宝贵的时间。很多题解，在我掌握题目后去看都费劲，更何况对于一些初学者。 本教程阅读门槛 本教程基本没有学习门槛。因为在每道题目中，我都会尽量去串基础知识，以达到学以致用的效果。 学完本教程期望达到什么样的目的 掌握基本的数据结构与算法 掌握各类型高频面试算法题 本教程有何特色 每一道算法题都配有完整图解！仅此一家！ 题解是围绕什么编写的 掌握！所有的题解都以掌握二字为前提。不会追求过多的奇淫技巧，毕竟我们不是专门研究算法的人。我见过太多算法初学者，一个题解看不懂，转头又去看第二个题解，第二个看不懂，又去看第三个，直到最后放弃掉。浪费了时间，题目还是不会做，这图什么呢？所以本教程所有的题解都是以掌握为目标，尽量把每一道题的思路都讲的明明白白的。 题解是否严谨 绝对严谨，所有的题解都在leetcode上进行过测试运行。 没学过 java、go 是否可以学习 当然可以。我期望大家更多的是去关注算法的本身，而不是语言层面的东西。所以本教程，其实各语言都会使用一些，并不局限于 java、go。但是，我绝对不会使用任何语法特性！我希望大家不要被语言所束缚！ 是否可以按照本教程顺序来刷题 当然可以。一般刷题我们有两种策略，一种就是刷 leetcode 前一百道题目，另一种就是根据分类刷题。刷 leetcode 前一百道题，是因为这些题目都是经典题目。而根据分类，更适合算法小白和初中阶段读者。所以我在这里选择了根据分类来汇编，这样我们还可以在做一些题目的时候，与前面同类型的题目进行比较。 这些题目刷完能达到什么效果 刷完再说！ 你需要做什么 开干！奥利给！ 看完题目还是不懂怎么办？ 下方扫码，加我微信，我拉你到刷题群。和大家一起交流学习！（备注：进群） 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:44:43 "},"c0/001.html":{"url":"c0/001.html","title":"01.两个数组的交集(350)","keywords":"","body":"两个数组的交集 01、题目分析 我们先来看一道题目： 第350题：两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？将如何优化你的算法呢？ 思路：设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。 02、题解分析 首先拿到这道题，我们基本马上可以想到，此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了。剩下的就是顺利成章的解题。 由于该种解法过于简单，我们不做进一步分析，直接给出题解： //GO func intersect(nums1 []int, nums2 []int) []int { m0 := map[int]int{} for _, v := range nums1 { //遍历nums1，初始化map m0[v] += 1 } k := 0 for _, v := range nums2 { //如果元素相同，将其存入nums2中，并将出现次数减1 if m0[v] > 0 { m0[v] -=1 nums2[k] = v k++ } } return nums2[0:k] } 这个方法比较简单，相信大家都能看的懂！ 03、题目进阶 题目在进阶问题中问道：如果给定的数组已经排好序呢？你将如何优化你的算法？我们分析一下，假如两个数组都是有序的，分别为：arr1 = [1,2,3,4,4,13]，arr2 = [1,2,3,9,10] 对于两个已经排序好数组的题，我们可以很容易想到使用双指针的解法~ 解题步骤如下： 设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。下图中我们的指针分别指向第一个元素，判断元素相等之后，将相同元素放到空白的数组。 如果两个指针的元素不相等，我们将小的一个指针后移。图中我们指针移到下一个元素，判断不相等之后，将元素小的指针向后移动，继续进行判断。 反复以上步骤。 直到任意一个数组终止。 04、题目解答 根据分析，我们很容易得到下面的题解： //GO func intersect(nums1 []int, nums2 []int) []int { i, j, k := 0, 0, 0 sort.Ints(nums1) sort.Ints(nums2) for i nums2[j] { j++ } else if nums1[i] 提示：解答中我们并没有创建空白数组，因为遍历后的数组其实就没用了。我们可以将相等的元素放入用过的数组中，就为我们节省下了空间。 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 17:44:00 "},"c0/002.html":{"url":"c0/002.html","title":"02.最长公共前缀(14)","keywords":"","body":"最长公共前缀 01、题目分析 首先还是看下题目： 题目14: 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，则返回\"\" 示例1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明： 所有输入只包含小写字母 a-z 02、题解分析 我们要想寻找最长公共前缀，那么首先这个前缀是公共的，我们可以从任意一个元素中找到它。假定我们现在就从一个数组中寻找最长公共前缀，那么首先，我们可以将第一个元素设置为基准元素x0。假如数组为[\"flow\",\"flower\",\"flight\"]，flow就是我们的基准元素x0。 然后我们只需要依次将基准元素和后面的元素进行比较（假定后面的元素依次为x1,x2,x3....），不断更新基准元素，直到基准元素和所有元素都满足最长公共前缀的条件，就可以得到最长公共前缀。 具体比对过程如下： 如果strings.Index(x1,x) == 0，则直接跳过（因为此时x就是x1的最长公共前缀），对比下一个元素。（如flower和flow进行比较） 如果strings.Index(x1,x) != 0, 则截取掉基准元素x的最后一个元素，再次和x1进行比较，直至满足string.Index(x1,x) == 0，此时截取后的x为x和x1的最长公共前缀。（如flight和flow进行比较，依次截取出flow-flo-fl，直到fl被截取出，此时fl为flight和flow的最长公共前缀） 具体过程如下图所示： 我们需要注意的是，在处理基准元素的过程中，如果基准元素和任一一个元素无法匹配，则说明不存在最长公共元素。 最后，我们记得处理一下临界条件。如果给定数组是空，也说明没有最长公共元素。 然后我们就可以开始写我们的代码了。 03、代码分析 根据分析，我们很容易得到下面的题解： //GO func longestCommonPrefix(strs []string) string { if len(strs) 运行结果： 当然，我们也可以用分治法或者其他方法来解答这道题目。你可以自己尝试尝试哈。我们下期见！ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-03 09:36:18 "},"c0/003.html":{"url":"c0/003.html","title":"03.买卖股票的最佳时机(122)","keywords":"","body":"买卖股票的最佳时机 01、题目分析 在leetcode上，股票相关的题目有8道之多： 而且这一类型的题，面试时出现的频率非常的高。稍微改一改条件，就让我们防不胜防。那我们如何攻克这一类题型呢？我们从最简单的一道开始看起： 第122题：买卖股票的最佳时机 II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 ​ 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 ​ 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 ​ 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 题目分析：首先我们看一下题目中给出的两个条件： 1、不能参与多笔交易。换句话讲，我们只能在手上没有股票的时候买入，也就是必须在再次购买前出售掉之前的股票。像我们平时买股票时的追涨杀跌是不可以的。 2、尽可能地多进行交易。这个非常好理解。像是黄金，一年基本上都有2-3次涨跌。我们只要把握住机会，在每一次涨跌的时候，低价卖入高价卖出，就可以使利益达到最大化。这个条件也是相当重要的，如果我们把这里变成，最多完成两笔交易，就变成另一道题。 现在题目搞清楚了，我们来思考一下。 02、题解分析 假设给定的数组为：[7, 1, 5, 3, 6, 4] 我们将其绘制成折线图，大概是下面这样： 如我们上面分析，我们要在满足1和2的条件下获取最大利益，其实就是尽可能多的低价买入高价卖出。而每一次上升波段，其实就是一次低价买入高价卖出。而我们没有限制交易次数，也就是我们需要求出所有的上升波段的和。上图里就是A+B，也就是（5-1）+（6-3） = 7，就是我们能获取到的最大利益。 其实也就是尽可能多的低价买入，高价卖出啦。 03、代码分析 根据以上分析，我们很容易得到下面的题解： //GO func maxProfit(prices []int) int { if len(prices) b { return a } return b } 04、题目扩展 图解的方式其实在各种算法题中，屡见不鲜。而我们通过图解的方式，也可以抽丝剥茧一样，一层一层剥掉算法题目的外壳，寻找到最直观的解题思路，直捣黄....咳咳，直奔核心。那我们又如何用图解的观察方式，来对本系列的其他题目寻找到一种通用解法，来规避题目中的陷阱呢？浩仔讲算法，我们下期再见喽！ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-03 09:36:18 "},"c0/004.html":{"url":"c0/004.html","title":"04.旋转数组(189)","keywords":"","body":"旋转数组 01、题目分析 题目189: 旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 这道题如果不要求原地翻转的话，其实相当简单。但是原地翻转的方法却并不容易想到，我们直接看题解。 02、题目图解 这个方法基于这个事实：若我们需要将数组中的元素向右移动 k 个位置， 那么 k%l (l为数组长度) 的尾部元素会被移动到头部，剩下的元素会被向后移动。 假设 我们现在数组为[1,2,3,4,5,6,7], l=7 且 k=3 。 如下图可以看到5,6,7 被移动到 数组头部。 通过观察我们可以得到，我们要得到最终的结果。我们只需要将所有元素反转，然后反转前 k 个元素，再反转后面l-k个元素，就能得到想要的结果。 如下图： 03、题目解答 根据分析，我们可以得到下面的题解： //GO func rotate(nums []int, k int) { reverse(nums) reverse(nums[:k%len(nums)]) reverse(nums[k%len(nums):]) } func reverse(arr []int) { for i := 0; i 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c0/005.html":{"url":"c0/005.html","title":"05.原地删除(27)","keywords":"","body":"原地删除 01、题目分析 题目27：移除元素 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 这道题比较简单哦，只要把握好“原地删除”这个关键字，就可以顺利求解啦！ 具体过程如下图所示： 根据分析，我们可以得到下面的题解： //GO func removeElement(nums []int, val int) int { for i := 0; i 和这道题类似的还有LeetCode 26题，大家可以尝试自己先做一做，然后再看答案哦。 02、类似题目分析 题目26：删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次。 返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 这道题的重点是原地两个字，也就是要求必须在O(1)的空间下完成。并且题中已经告知了数组为有序数组，这样重复的元素一定是连在一起的，我们只需要一个一个移除重复的元素即可，具体方案方案怎么做，我们看看下面就会明白了。 移除的具体过程： 根据分析，我们可以得到下面的题解： //GO func removeDuplicates(nums []int) int { for i := 0; i+1 好啦，关于数组原地操作的两道题就讲到这里啦，如果大家有兴趣的话，可以参考做一下LeetCode 283题（移动O），也是一样的做法哦！ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c0/006.html":{"url":"c0/006.html","title":"06.加一(66)","keywords":"","body":"加一 看到这个标题，大家肯定会觉得，不就是“加1”嘛，这么简单的问题我可以！但是就是这么简单的“加1”可是面试的高频题哦，所以我们就一起来看看吧。按照往例，我们还是从一道LeetCode题开始吧。 01、题目分析 第66题：加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 题目分析： 根据题目，我们需要加一！没错，加一很重要。因为它只是加一，所以我们会考虑到两种情况： 普通情况，除9之外的数字加1。 特殊情况，9加1。（因为9加1需要进位） 所以我们只需要模拟这两种运算，就可以顺利进行求解！ 02、题目图解 假设我们的数为[1,9,9] 大概是下面这样：（这个图解...真的有点太简单了...） 当然，这里我们需要考虑一种特殊情况，就是类似99，或者999，我们需要进行拼接数组。具体如下图： 通过以上分析，我们最后只需要将其转换成代码即可！这样看来，“加1”是不是也不像想象中的那么简单？ 03、GO语言示例 根据以上分析，我们可以得到下面的题解： func plusOne(digits []int) []int { var result []int addon := 0 for i := len(digits) - 1;i >= 0; i-- { digits[i]+=addon addon = 0 if i == len(digits) - 1 { digits[i]++ } if digits[i] == 10 { addon = 1 digits[i] = digits[i] % 10 } } if addon == 1 { result = make([]int, 1) result[0] = 1 result = append(result,digits...) }else{ result = digits } return result } 提示: append(a,b...) 的含义是：将b切片中的元素追加到a中。 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c0/007.html":{"url":"c0/007.html","title":"07.两数之和(1)","keywords":"","body":"两数之和 01、题目分析 第1题：两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 题目分析 首先我们拿到题目一看，马上可以想到暴力题解。我们只需要 “遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。” 由于该种解题思路过于简单，直接上代码（如果有问题请留言..）： func twoSum(nums []int, target int) []int { for i, v := range nums { for k := i + 1; k 执行结果： 运行成功，但是该种解题方式的时间复杂度过高，达到了O(n²)。为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。我们可以想到用哈希表的方式，通过以空间换取时间的方式来进行。 02、题目图解 假设 nums = [2, 7, 11, 15], target = 9 首先，我们还是先遍历数组 nums，i 为当前下标。我们需要将每一个遍历的值放入 map 中作为 key。 同时，对每个值都判断 map 中是否存在 target-nums[i] 的 key 值。在这里就是 9-7=2。我们可以看到 2 在 map 中已经存在。 所以，2 和 7 所在的 key 对应的 value，也就是 [0,1]。就是我们要找的两个数组下标。 03、Go语言示例 根据以上分析，我们可以得到下面的题解： func twoSum(nums []int, target int) []int { result := []int{} m := make(map[int]int) for i,k := range nums { if value,exist := m[target-k];exist { result = append(result,value) result = append(result,i) } m[k] = i } return result } 执行结果： 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c1/101.html":{"url":"c1/101.html","title":"01.删除链表倒数第N个节点(19)","keywords":"","body":"删除链表倒数第N个节点 01、哨兵节点 在链表的题目中，十道有九道会用到哨兵节点，所以我们先讲一下什么是哨兵节点。 哨兵节点，其实就是一个附加在原链表最前面用来简化边界条件的附加节点，它的值域不存储任何东西，只是为了操作方便而引入。 比如原链表为a->b->c，则加了哨兵节点的链表即为x->a->b>c，如下图： 那我们为什么需要引入哨兵节点呢?举个例子，比如我们要删除某链表的第一个元素，常见的删除链表的操作是找到要删元素的前一个元素，假如我们记为 pre。我们通过： pre.Next = pre.Next.Next 来进行删除链表的操作。但是此时若是删除第一个元素的话，你就很难进行了，因为按道理来讲，此时第一个元素的前一个元素就是nil（空的），如果使用pre就会报错。那如果此时你设置了哨兵节点的话，此时的pre就是哨兵节点了。这样对于链表中的任何一个元素，你要删除都可以通过pre.Next=pre.Next.Next的方式来进行，这就是哨兵节点的作用。 下面我们看一道题目，看一下哨兵节点的应用 02、题目讲解 第19题：删除链表倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路分析： 首先我们思考，让我们删除倒数第N个元素，那我们只要找到倒数第N个元素就可以了，那怎么找呢？我们只需要设置两个指针变量，中间间隔N-1元素。当后面的指针遍历完所有元素指向nil时，前面的指针就指向了我们要删除的元素。如下图所示： 接下来，我们只要同时定位到要删除的元素的前1个元素，通过前面讲过的删除操作，就可以很顺利的完成这道题目啦。 03、解题过程 现在我们来完整捋一遍解题过程： 首先我们定义好哨兵节点result，指向哨兵节点的目标元素指针cur，以及目标指针cur的前一个指针pre，此时pre指向nil。 接下来我们开始遍历整个链表。 当head移动到距离目标元素cur的距离为N-1时，同时开始移动cur。 当链表遍历完之后，此时head指向nil，这时的cur就是我们要找的待删除的目标元素。 最后我们通过pre.Next = pre.Next.Next完成删除操作，就完成了整个解题过程。 下面是解题过程图，可以看得更清楚哦。 04、题目解答 根据以上分析，我们可以得到下面的题解： func removeNthFromEnd(head *ListNode, n int) *ListNode { result := &ListNode{} result.Next = head var pre *ListNode cur := result i := 1 for head != nil { if i >= n { pre = cur cur = cur.Next } head = head.Next i++ } pre.Next = pre.Next.Next return result.Next } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c1/102.html":{"url":"c1/102.html","title":"02.合并两个有序链表(21)","keywords":"","body":"合并两个有序链表 01、题目分析 第21题：合并两个有序链表 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 首先我们拿到题目乍眼一看，类似这种链表的合并问题。基本上马上可以想到需要设置一个哨兵节点，这可以在最后让我们比较容易地返回合并后的链表。（不懂哨兵节点的同学，可以先移驾到 06.删除链表倒数第N个节点(19) 进行学习） 假设我们的链表分别为: l1 = [1,2,4] l2 = [1,3,4] 同时我们设定一个 \"prehead\" 的哨兵节点,大概是下面这样： 02、题目图解 如上图所示，首先我们维护一个 prehead 的哨兵节点。我们其实只需要调整它的 next 指针。让它总是指向l1或者l2中较小的一个，直到l1或者l2任一指向null。这样到了最后，如果l1还是l2中任意一方还有余下元素没有用到，那余下的这些元素一定大于prehead已经合并完的链表（因为是有序链表）。我们只需要将这些元素全部追加到prehead合并完的链表后，最终就得到了我们需要的链表。大概流程如下： 首先我们将 prehead 指向 l1 或者 l2 中比较小的一个。如果相等，则任意一个都可以。此时的 l1 为 [2,4]，l2 为 [1,3,4] 我们继续上面的步骤。将 prehead 的链表指向 l1 和 l2 中较小的一个。现在这里就是指向1。 反复上图步骤。 现在 prehead.Next 就是我们需要的链表。 03、Go语言示例 根据以上分析，我们可以得到下面的题解： func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { prehead := &ListNode{} result := prehead for l1 != nil && l2 != nil { if l1.Val 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c1/103.html":{"url":"c1/103.html","title":"03.环形链表(21)","keywords":"","body":"环形链表 今天为大家带来，链表检测成环的经典题目。如果你觉得你会了，请你不妨耐心些认真看下去，我相信会有一些不一样的收获！还是先从一道题目开始哟，准备好了吗？ Let' s go ! 01、题目分析 第141题：环形链表 给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 题目可能你会觉得过于简单！但是不妨耐心看完！ 则一定会有收获！ 02、题目分析 题解一：哈希表判定 思路：通过hash表来检测节点之前是否被访问过，来判断链表是否成环。这是最容易想到的一种题解了。过于简单，直接上代码： func hasCycle(head *ListNode) bool { m := make(map[*ListNode]int) for head != nil { if _,exist := m[head];exist { return true } m[head]= 1 9 head = head.Next } return false12 } 题解二：JS特殊解法 相信对于 JS 中的 JSON.stringify() 方法大家都用过，主要用于将 JS 对象 转换为 JSON 字符串。基本使用如下： var car = { name: '小喵', age: 20, } var str = JSON.stringify(car); console.log(str) //=> {\"name\":\"小喵\",\"age\":20} 大家想一下，如果是自己实现这样的一个函数，我们需要处理什么样的特殊情况？对，就是循环引用。因为对于循环引用，我们很难通过 JSON 的结构将其进行展示！比如下面： var a = {} var b = { a: a } a.b = b console.log(JSON.stringify(a)) //=> TypeError: Converting circular structure to JSON 那我们思考，对于环形链表，是不是就是一个循环结构呢？当然是！因为只要是环形链表，它一定存在类似以下代码： a.Next = b b.Next = a 所以我们可以通过 JSON.stringify() 的特性进行求解： var hasCycle = function(head) { try{ JSON.stringify(head) }catch(e){ return true } return false }; 当然，这种解法并不是建议的标准题解！在此列出是为了拓宽思维！（大家如有兴趣，可以自己去看下JSON.stringify 内部的实现，是如何检测循环引用的。） 题解三：双指针解法 本题标准解法！常识内容，必须掌握！ 思路来源：先想象一下，两名运动员以不同速度在跑道上进行跑步会怎么样？相遇！好了，这道题你会了。 解题方法：通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。 假设链表为 , 其步骤如下： 分析完毕，直接上代码： func hasCycle(head *ListNode) bool { if head == nil { return false } fast := head.Next // 快指针，每次走两步 for fast != nil && head != nil && fast.Next != nil { if fast == head { // 快慢指针相遇，表示有环 return true } fast = fast.Next.Next head = head.Next // 慢指针，每次走一步 } return false } 这里我们要特别说明一下，为什么慢指针的步长设置为 1 ，而快指针步长设置为 2 。 首先，慢指针步长为 1，很容易理解，因为我们需要让慢指针步行至每一个元素。而快指针步长为 2 ，通俗点可以理解为他们的相对速度只差 1，快的只能一个一个格子的去追慢的，必然在一个格子相遇。 如果没看懂，我们来分析：在快的快追上慢的时，他们之间一定是只差 1 个或者 2 个格子。如果落后 1 个，那么下一次就追上了。如果落后 2 个，那么下一次就落后 1 个，再下一次就能追上！如下图： 所以我们的快指针的步长可以设置为 2 。 03、特别说明 我们常会遇到一些所谓的“简单题目“，然后用着前人留下来的那些”经典题解“迅速作答。在解题的过程中，追求公式化、模板化。当然，这个过程是好的，因为社会、工作、学业要求我们如此！但是，我希望我们也可以留下一些自己的思考，纵然不是最优解，但是是我们自己想到的、创造的！真正在算法题中去收获快乐～ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"c2/201.html":{"url":"c2/201.html","title":"01.爬楼梯(70)","keywords":"","body":"DP 第一讲 - 爬楼梯 01、概念讲解 关于动态规划的资料很多，官方的定义是指把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。概念中的各阶段之间的关系，其实指的就是状态转移方程。很多人觉得DP难（下文统称动态规划为DP），根本原因是因为DP跟一些固定形式的算法不同（比如DFS、二分法、KMP），它没有实际的步骤规定第一步、第二步来做什么，所以准确来说，DP其实是一种解决问题的思想。 这种思想的本质是：一个规模比较大的问题（可以用两三个参数表示的问题），可以通过若干规模较小的问题的结果来得到的（通常会寻求到一些特殊的计算逻辑，如求最值等），如下图所示，一个大规模的问题由若干个子问题组成。 那么我们应该如何通过子问题去得到大规模问题呢？这就用到了状态转移方程（上面有介绍状态转移方程哦，不懂的请往上翻哦），我们一般看到的状态转移方程，基本都是这样： opt ：指代特殊的计算逻辑，通常为 max or min。 i,j,k 都是在定义DP方程中用到的参数。 dp[i] = opt(dp[i-1])+1 dp[i][j] = w(i,j,k) + opt(dp[i-1][k]) dp[i][j] = opt(dp[i-1][j] + xi, dp[i][j-1] + yj, ...) 每一个状态转移方程，多少都有一些细微的差别。这个其实很容易理解，世间的关系多了去了，不可能抽象出完全可以套用的公式。所以我个人其实不建议去死记硬背各种类型的状态转移方程。但是DP的题型真的就完全无法掌握，无法归类进行分析吗？我认为不是的。在本系列中，我将由简入深为大家讲解动态规划这个主题。 02、题目分析 我们先看一道最简单的DP题目，熟悉DP的概念： 第70题：爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 03 、图解分析 通过分析我们可以明确，该题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建。满足“将大问题分解为若干个规模较小的问题”的条件。所我们令 dp[n] 表示能到达第 n 阶的方法总数，可以得到如下状态转移方程： dp[n]=dp[n-1]+dp[n-2] 上 1 阶台阶：有1种方式。 上 2 阶台阶：有1+1和2两种方式。 上 3 阶台阶：到达第3阶的方法总数就是到第1阶和第2阶的方法数之和。 上 n 阶台阶，到达第n阶的方法总数就是到第 (n-1) 阶和第 (n-2) 阶的方法数之和。 04、GO语言示例 根据以上分析，可以得到代码如下： func climbStairs(n int) int { if n == 1 { return 1 } dp := make([]int, n+1) dp[1] = 1 dp[2] = 2 for i := 3; i 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c2/202.html":{"url":"c2/202.html","title":"02.最大子序和(53)","keywords":"","body":"DP 第二讲 - 最大子序和 在上一篇文章011.动态规划系列 —第一讲(70)中，我们讲解了DP的概念并且通过示例了解了什么是动态规划。本篇中，我们将继续通过1道简单题型，进一步学习动态规划的思想。 01、题目分析 第53题：最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 拿到题目请不要直接看下方题解，先自行思考2-3分钟.... 02、题目图解 首先我们分析题目，一个连续子数组一定要以一个数作为结尾，那么我们可以将状态定义成如下： dp[i]：表示以 nums[i] 结尾的连续子数组的最大和。 那么为什么这么定义呢？因为这样定义其实是最容易想到的！在上一节中我们提到，状态转移方程其实是通过1-3个参数的方程来描述小规模问题和大规模问题间的关系。 当然，如果你没有想到，其实也非常正常！因为该问题最早于 1977 年提出，但是直到 1984 年才被发现了线性时间的最优解法。 根据状态的定义，我们继续进行分析：如果要得到 dp[i]，那么 nums[i] 一定会被选取。并且 dp[i] 所表示的连续子序列与 dp[i-1] 所表示的连续子序列很可能就差一个 nums[i] 。即： dp[i] = dp[i-1]+nums[i] , if (dp[i-1] >= 0) 但是这里我们遇到一个问题，很有可能 dp[i-1] 本身是一个负数。那这种情况的话，如果 dp[i] 通过 dp[i-1]+nums[i] 来推导，那么结果其实反而变小了，因为我们 dp[i] 要求的是最大和。所以在这种情况下，如果 dp[i-1] 。即 dp[i] = nums[i] , if (dp[i-1] 综上分析，我们可以得到： dp[i]=max(nums[i], dp[i−1]+nums[i]) 得到了状态转移方程，但是我们还需要通过一个已有的状态的进行推导，我们可以想到 dp[0] 一定是以 nums[0] 进行结尾，所以 dp[i] = dp[i-1]+nums[i] , if (dp[i-1] >= 0) dp[0] = nums[0] 在很多题目中，因为 dp[i] 本身就定义成了题目中的问题，所以 dp[i] 最终就是要的答案。但是这里状态中的定义，并不是题目中要的问题，不能直接返回最后的一个状态 (这一步经常有初学者会摔跟头)。所以最终的答案，其实我们是寻找： max(dp[0], dp[1], ..., d[i-1], dp[i]) 分析完毕，我们绘制成图（图中假定 nums 为 [-2,1,-3,4,-1,2,1,-5,4]）： 03、Go语言示例 根据以上分析，可以得到代码如下： //Go func maxSubArray(nums []int) int { if len(nums) b { return a } return b } 我们可以进一步精简代码为： //Go func maxSubArray(nums []int) int { if len(nums) b { return a } return b } 复杂度分析：时间复杂度：O(N)。空间复杂度：O(N) 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c2/203.html":{"url":"c2/203.html","title":"03.最长上升子序列(300)","keywords":"","body":"DP 第三讲 - 最长上升子序列 在上一篇中，我们了解了什么是DP（动态规划），并且通过DP中的经典问题 \"最大子序和\"，学习了状态转移方程应该如何定义。在本节中，我们将沿用之前的分析方法，通过一道例题，进一步巩固之前的内容！ 01、题目分析 第300题：最长上升子序列 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 这道题有一定难度哦！如果没有思路请回顾上一篇的学习内容！ 不建议直接看题解！ 02、题目图解 首先我们分析题目，要找的是最长上升子序列（Longest Increasing Subsequence，LIS）。因为题目中没有要求连续，所以LIS可能是连续的，也可能是非连续的。同时，LIS符合可以从其子问题的最优解来进行构建的条件。所以我们可以尝试用动态规划来进行求解。首先我们定义状态： dp[i] ：表示以nums[i]结尾的最长上升子序列的长度 我们假定nums为[1，9，5，9，3]，如下图： 我们分两种情况进行讨论： 如果nums[i]比前面的所有元素都小，那么dp[i]等于1（即它本身）（该结论正确） 如果nums[i]前面存在比他小的元素nums[j]，那么dp[i]就等于dp[j]+1（该结论错误，比如nums[3]>nums[0]，即9>1,但是dp[3]并不等于dp[0]+1） 我们先初步得出上面的结论，但是我们发现了一些问题。因为dp[i]前面比他小的元素，不一定只有一个！ 可能除了 nums[j]，还包括 nums[k]，nums[p] 等等等等。所以 dp[i] 除了可能等于 dp[j]+1，还有可能等于 dp[k]+1，dp[p]+1 等等等等。所以我们求 dp[i]，需要找到 dp[j]+1，dp[k]+1，dp[p]+1 等等等等 中的最大值。（我在3个等等等等上都进行了加粗，主要是因为初学者非常容易在这里摔跟斗！这里强调的目的是希望能记住这道题型！） 即： dp[i] = max(dp[j]+1，dp[k]+1，dp[p]+1，.....) 只要满足： nums[i] > nums[j] nums[i] > nums[k] nums[i] > nums[p] .... 最后，我们只需要找到dp数组中的最大值，就是我们要找的答案。 分析完毕，我们绘制成图： 03、Go语言示例 根据以上分析，可以得到代码如下： func lengthOfLIS(nums []int) int { if len(nums) b { return a } return b } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c2/204.html":{"url":"c2/204.html","title":"04.三角形最小路径和(120)","keywords":"","body":"DP 第二讲 - 三角形最小路径和 在上一篇中，我们通过题目“最长上升子序列” 以及 \"最大子序和\"，学习了DP（动态规划）在线性关系中的分析方法。这种分析方法，也在运筹学中被称为“线性动态规划”，具体指的是 “目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值”。这点大家作为了解即可，不需要死记，更不要生搬硬套！ 在本节中，我们将继续分析一道略微区别于之前的题型，希望可以由此题与之前的题目进行对比论证，进而顺利求解！ 01、题目分析 第120题：三角形最小路径和 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 则自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 这道题有一定难度哦！如果没有思路请回顾上一篇的学习内容！ 不建议直接看题解！ 02、题目图解 首先我们分析题目，要找的是三角形最小路径和，这是个啥意思呢？假设我们有一个三角形：[[2], [3,4], [6,5,7]， [4,1,8,3]] 那从上到下的最小路径和就是2-3-5-1，等于11。 由于我们是使用数组来定义一个三角形，所以便于我们分析，我们将三角形稍微进行改动： 这样相当于我们将整个三角形进行了拉伸。这时候，我们根据题目中给出的条件：每一步只能移动到下一行中相邻 的结点上。其实也就等同于，每一步我们只能往下移动一格或者右下移动一格。将其转化成代码，假如2所在的元 素位置为[0,0]，那我们往下移动就只能移动到[1,0]或者[1,1]的位置上。假如5所在的位置为[2,1]，同样也只能移动 到[3,1]和[3,2]的位置上。如下图所示： 题目明确了之后，现在我们开始进行分析。题目很明显是一个找最优解的问题，并且可以从子问题的最优解进 行构建。所以我们通过动态规划进行求解。首先，我们定义状态： dp[i][j] : 表示包含第i行j列元素的最小路径和 我们很容易想到可以自顶向下进行分析。并且，无论最后的路径是哪一条，它一定要经过最顶上的元素，即 [0,0]。所以我们需要对 dp[0][0] 进行初始化。 dp[0][0] = [0][0]位置所在的元素值 继续分析，如果我们要求dp[i][j]，那么其一定会从自己头顶上的两个元素移动而来。 如5这个位置的最小路径和，要么是从2-3-5而来，要么是从2-4-5而来。然后取两条路径和中较小的一个即可。进 而我们得到状态转移方程： dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]) + triangle[i][j] 但是，我们这里会遇到一个问题！除了最顶上的元素之外， 最左边的元素只能从自己头顶而来。（2-3-6-4） 最右边的元素只能从自己左上角而来。（2-4-7-3） 然后，我们观察发现，位于第2行的元素，都是特殊元素（因为都只能从[0,0]的元素走过来） 我们可以直接将其特殊处理，得到： dp[1][0] = triangle[1][0] + triangle[0][0] dp[1][1] = triangle[1][1] + triangle[0][0] 最后，我们只要找到最后一行元素中，路径和最小的一个，就是我们的答案。即： l：dp数组长度 result = min(dp[l-1,0]，dp[l-1,1]，dp[l-1,2]....) 综上我们就分析完了，我们总共进行了4步： 定义状态 总结状态转移方程 分析状态转移方程不能满足的特殊情况。 得到最终解 03、Go语言示例 根据以上分析，可以得到代码如下： func minimumTotal(triangle [][]int) int { if len(triangle) b { return b } return a } 运行结果： 运行上面的代码，我们发现使用的内存过大。我们有没有什么办法可以压缩内存呢？通过观察我们发现，在我们 自顶向下的过程中，其实我们只需要使用到上一层中已经累积计算完毕的数据，并且不会再次访问之前的元素数 据。绘制成图如下： 优化后的代码如下： func minimumTotal(triangle [][]int) int { l := len(triangle) if l b { return b } return a } 运行结果： 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 17:25:12 "},"c2/205.html":{"url":"c2/205.html","title":"05.最小路径和(64)","keywords":"","body":"DP 第五讲 - 最小路径和 在上一篇中，我们通过分析，顺利完成了“三角形最小路径和”的动态规划题解。在本节中，我们继续看一道相似题型，以求能完全掌握这种“路径和”的问题。话不多说，先看题目： 01、题目分析 第64题：最小路径和 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 这道题有一定难度哦！如果没有思路请回顾上一篇的学习内容！ 不建议直接看题解！ 02、题目图解 首先我们分析题目，要找的是 最小路径和，这是个啥意思呢？假设我们有一个 m * n 的矩形 ：[[1,3,1],[1,5,1],[4,2,1]] 那从左上角到右下角的最小路径和，我们可以很容易看出就是 1-3-1-1-1 ，这一条路径，结果等于 7 。 题目明确了，我们继续进行分析。该题与上一道求三角形最小路径和一样，题目明显符合可以从子问题的最优解进行构建，所以我们考虑使用动态规划进行求解。首先，我们定义状态： dp[i][j] : 表示包含第i行j列元素的最小路径和 同样，因为任何一条到达右下角的路径，都会经过 [0,0] 这个元素。所以我们需要对 dp[0][0] 进行初始化。 dp[0][0] = [0][0]位置所在的元素值 继续分析，根据题目给的条件，如果我们要求 dp[i][j] ，那么它一定是从自己的上方或者左边移动而来。如下图所示： 5，只能从3或者1移动而来 2，只能从5或者4移动而来 4，从1移动而来 3，从1移动而来 （红色位置必须从蓝色位置移动而来） 进而我们得到状态转移方程： dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j] 同样我们需要考虑两种特殊情况： 最上面一行，只能由左边移动而来（1-3-1） 最左边一列，只能由上面移动而来（1-1-4） 最后，因为我们的目标是从左上角走到右下角，整个网格的最小路径和其实就是包含右下角元素的最小路径和。即： 设：dp的长度为l 最终结果就是：dp[l-1][len(dp[l-1])-1] 综上我们就分析完了，我们总共进行了 4 步： 定义状态 总结状态转移方程 分析状态转移方程不能满足的特殊情况。 得到最终解 03、GO语言示例 根据以上分析，可以得到代码如下： func minPathSum(grid [][]int) int { l := len(grid) if l b { return b } return a } 运行结果： 同样，运行上面的代码，我们发现使用的内存过大。有没有什么办法可以压缩内存呢？通过观察我们发现，在我们自左上角到右下角计算各个节点的最小路径和的过程中，我们只需要使用到之前已经累积计算完毕的数据，并且不会再次访问之前的元素数据。绘制成图如下：(大家看这个过程像不像扫雷，其实如果大家研究扫雷外挂的话，就会发现在扫雷的核心算法中，就有一处颇为类似这种分析方法，这里就不深究了) 优化后的代码如下： func minPathSum(grid [][]int) int { l := len(grid) if l b { return b } return a } 运行结果： 课后思考：路径和类问题和之前的子序列类问题有何区别？ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-05 15:11:35 "},"c2/206.html":{"url":"c2/206.html","title":"06.打家劫舍(198)","keywords":"","body":"DP 第六讲 - 打家劫舍 在前两篇中，我们分别学习了 “三角形最小路径和” 以及“矩形最小路径和” 的问题，相信已经掌握了这类题型的解题方式。我们只要明确状态的定义，基本上都可以顺利求解。 在本节中，我们将回归一道简单点的题目，目的是剖析一下状态定义的过程，并且举例说明如果状态定义错误，会对我们带来多大困扰！希望大家不要轻视！ 01、题目分析 第198题：打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 本题主要剖析状态定义的过程！强烈建议先进行前面5节内容的学习！ 以达到最好的学习效果！ 02、题目图解 假设有i间房子，我们可能会定义出两种状态： dp[i] : 偷盗 含 第 i个房子时，所获取的最大利益 dp[i] : 偷盗 至 第 i个房子时，所获取的最大利益 如果我们定义为状态一，因为我们没办法知道获取最高金额时，小偷到底偷盗了哪些房屋。所以我们需要找到所有状态中的最大值，才能找到我们的最终答案。即： max(dp[0],dp[1],.....,dp[len(dp)-1]) 如果我们定义为状态二，因为小偷一定会从前偷到最后（强调：偷盗至第i个房间，不代表小偷要从第i个房间中获取财物）。所以我们的最终答案很容易确定。即： dp[i] 现在我们分析这两种状态定义下的状态转移方程： 如果是状态一，偷盗含第 i 个房间时能获取的最高金额，我们相当于要找到偷盗每一间房子时可以获取到的最大金额。比如下图，我们要找到 dp[4] ，也就是偷盗 9 这间房子时，能获取到的最大金额。 那我们就需要找到与9不相邻的前后两段中能获取到的最大金额。 我们发现题目进入恶性循环，因为我们若要找到与9不相邻的两端中能偷盗的最大金额，根据 dp[i] 的定义，我们就又需要分析在这两段中盗取每一间房子时所能获取的最大利益！想想都很可怕！所以我们放弃掉这种状态的定义。 如果是状态二，偷盗至第 i 个房子时，所能获取的最大利益。那我们可以想到，由于不可以在相邻的房屋闯入，所以 至i房屋可盗窃的最大值，要么就是至 i-1 房屋可盗窃的最大值，要么就是至 i-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值，即： dp[i] = max(dp[i-2]+nums[i], dp[i-1]) 如果不能理解可以看下图： （相当于小贼背了个背包，里边装了之前偷来的财物，每到达下一个房间门口，来选择是偷还是不偷。） 03、GO语言示例 分析完毕，我们根据第二种状态定义进行求解： func rob(nums []int) int { if len(nums) b { return a } return b } 运行结果： 同样，运行上面的代码，我们发现使用的内存过大。有没有什么办法可以压缩内存呢？我们很容易想到，在小贼偷盗的过程中，不可能转回头去到自己已经偷过的房间！（太蠢）小偷只需要每次将财物搬到下一个房间就行！ 根据上面思路，优化后的代码如下： func rob(nums []int) int { if len(nums) b { return a } return b } 运行结果： 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"c3/301.html":{"url":"c3/301.html","title":"01.反转字符串(344)","keywords":"","body":"反转字符串 01、题目分析 第344题：反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 示例 1： 输入：[\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 02、题目图解 这是一道相当简单的经典题目，直接上题解：使用双指针进行反转字符串。 假设输入字符串为[\"h\",\"e\",\"l\",\"l\",\"0\"] 定义left和right分别指向首元素和尾元素 当left 交换完毕，left++，right-- 直至left == right 具体过程如下图所示： 03、Go语言示例 根据以上分析，我们可以得到下面的题解： //Go func reverseString(s []byte) { left := 0 right := len(s) - 1 for left 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-04 14:05:22 "},"c3/302.html":{"url":"c3/302.html","title":"02.字符串中的第一个唯一字符(387)","keywords":"","body":"字符串中的第一个唯一字符 01、题目分析 第387题：字符串中的第一个唯一字符 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1 。 案例: s = \"leetcode\" 返回 0. s = \"loveleetcode\", 返回 2. 注意事项：您可以假定该字符串只包含小写字母。 常考题目，建议自行思考 1-2 分钟先～ 02、题目图解 题目不难，直接进行分析。由于字母共有 26 个，所以我们可以声明一个 26 个长度的数组（该种方法在本类题型很常用）因为字符串中字母可能是重复的，所以我们可以先进行第一次遍历，在数组中记录每个字母的最后一次出现的所在索引。然后再通过一次循环，比较各个字母第一次出现的索引是否为最后一次的索引。如果是，我们就找到了我们的目标，如果不是我们将其设为 -1（标示该元素非目标元素）如果第二次遍历最终没有找到目标，直接返回 -1即可。 图解如下： 03、GO语言示例 根据以上分析，可以得到代码如下： func firstUniqChar(s string) int { var arr [26]int for i,k := range s { arr[k - 'a'] = i } for i,k := range s { if i == arr[k - 'a']{ return i }else{ arr[k - 'a'] = -1 } } return -1 } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 11:53:05 "},"c4/401.html":{"url":"c4/401.html","title":"01.最大深度与DFS(104)","keywords":"","body":"二叉树第一讲 - 最大深度与DFS 在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。树比链表稍微复杂，因为链表是线性数据结构，而树不是。树的问题很多都可以由广度优先搜索或深度优先搜索解决。 在本系列中，我们将通过一些例题，学习关于二叉树的经典操作！ 01、题目分析 第104题：二叉树的最大深度 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 本系列内容均为必须掌握！ 02、递归求解 我们知道，每个节点的深度与它左右子树的深度有关，且等于其左右子树最大深度值加上 1 。即： maxDepth(root) = max(maxDepth(root.left), maxDepth(root.right)) + 1 以 [3,4,20,null,null,15,7] 为例： 我们要对根节点的最大深度求解，就要对其左右子树的深度进行求解 我们看出。以4为根节点的子树没有左右节点，其深度为 1 。而以 20 为根节点的子树的深度，同样取决于它的左右子树深度。 对于15和7的子树，我们可以一眼看出其深度为 1 。 由此我们可以得到根节点的最大深度为: maxDepth(root-3) =max(**maxDepth**(sub-4),**maxDepth**(sub-20))+1 =max(1,max(**maxDepth**(sub-15),**maxDepth**(sub-7))+1)+1 =max(1,max(1,1)+1)+1 =max(1,2)+1 =3 根据分析，我们通过递归进行求解代码如下： func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a int, b int) int { if a > b { return a } return b } 03、DFS 其实我们上面用的递归方式，本质上是使用了DFS的思想。先介绍一下DFS：深度优先搜索算法（Depth First Search），对于二叉树而言，它沿着树的深度遍历树的节点，尽可能深的搜索树的分支，这一过程一直进行到已发现从源节点可达的所有节点为止。 如上图二叉树，它的访问顺序为： A-B-D-E-C-F-G A-B-D-E-C-F-G 到这里，我们思考一个问题？虽然我们用递归的方式根据DFS的思想顺利完成了题目。但是这种方式的缺点却显而易见。因为在递归中，如果层级过深，我们很可能保存过多的临时变量，导致栈溢出。这也是为什么我们一般不在后台代码中使用递归的原因。如果不理解，下面我们详细说明： 事实上，函数调用的参数是通过栈空间来传递的，在调用过程中会占用线程的栈资源。而递归调用，只有走到最后的结束点后函数才能依次退出，而未到达最后的结束点之前，占用的栈空间一直没有释放，如果递归调用次数过多，就可能导致占用的栈资源超过线程的最大值，从而导致栈溢出，导致程序的异常退出。 所以，我们引出下面的话题：如何将递归的代码转化成非递归的形式。这里请记住，99%的递归转非递归，都可以通过栈来进行实现。 非递归的DFS，代码如下： private List traversal(TreeNode root) { List res = new ArrayList<>(); Stack stack = new Stack<>(); stack.add(root); while (!stack.empty()) { TreeNode node = stack.peek(); res.add(node); stack.pop(); if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return res; } 上面的代码，唯一需要强调的是，为什么需要先右后左压入数据？是因为我们需要将先访问的数据，后压入栈（请思考栈的特点）。 如果不理解代码，请看下图： 1：首先将a压入栈 2：a弹栈，将c、b压入栈（注意顺序） 3：b弹栈，将e、d压入栈 4：d、e、c弹栈，将g、f压入栈 5：f、g弹栈 至此，非递归的DFS就讲解完毕了。那我们如何通过非递归DFS的方式，来进行本题求解呢？相信已经很简单了，留下课后作业，请自行实践！ 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 12:12:49 "},"c4/402.html":{"url":"c4/402.html","title":"02.层次遍历与BFS(102)","keywords":"","body":"二叉树第二讲 - 层次遍历与BFS 在上一节中，我们通过例题学习了二叉树的DFS（深度优先搜索），其实就是沿着一个方向一直向下遍历。那我们可不可以按照高度一层一层的访问树中的数据呢？当然可以，就是本节中我们要讲的BFS（宽度优先搜索），同时也被称为广度优先搜索。 我们仍然通过例题进行讲解： 01、题目分析 第102题：二叉树的层次遍历 示例: 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果：[[3],[9,20],[15,7]] 本系列内容均为必须掌握！ 02、BFS介绍 BFS，广度/宽度优先。其实就是从上到下，先把每一层遍历完之后再遍历一下一层。假如我们的树如下： 按照BFS，访问顺序如下： a->b->c->d->e->f->g 了解了BFS，我们开始对本题进行分析。 03、递归求解 同样，我们先考虑本题的递归解法。想到递归，我们一般先想到DFS。我们可以对该二叉树进行先序遍历（根左右的顺序），同时，记录节点所在的层次level，并且对每一层都定义一个数组，然后将访问到的节点值放入对应层的数组中。 假设给定二叉树为[3,9,20,null,null,15,7]，图解如下： 根据以上分析，代码如下： func levelOrder(root *TreeNode) [][]int { return dfs(root, 0, [][]int{}) } func dfs(root *TreeNode, level int, res [][]int) [][]int { if root == nil { return res } if len(res) == level { res = append(res, []int{root.Val}) } else { res[level] = append(res[level], root.Val) } res = dfs(root.Left, level+1, res) res = dfs(root.Right, level+1, res) return res } 04、BFS求解 上面的解法，其实相当于是用DFS的方法实现了二叉树的BFS。那我们能不能直接使用BFS的方式进行解题呢？当然，我们可以使用Queue的数据结构。我们将root节点初始化进队列，通过消耗尾部，插入头部的方式来完成BFS。 具体步骤如下图： 根据以上分析，代码如下： func levelOrder(root *TreeNode) [][]int { var result [][]int if root == nil { return result } // 定义一个双向队列 queue := list.New() // 头部插入根节点 queue.PushFront(root) // 进行广度搜索 for queue.Len() > 0 { var current []int listLength := queue.Len() for i := 0; i 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 12:37:26 "},"sort/0.readme.html":{"url":"sort/0.readme.html","title":"排序算法","keywords":"","body":"排序专栏 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。是《数据结构与算法》中最基本的算法之一。 我们常说的十大排序算法为：冒泡、选择、插入、希尔、归并、快速、堆、计数、桶、基数 基本分类 我们常根据是否可以在线性时间内比较对其分类： 时间复杂度： 如何记忆时间复杂度呢？ 平方阶 (O(n2)) 插入、选择、冒泡 线性对数阶 (O(nlog2n)) 快速、归并、堆 特殊的希尔 O(n^(1.3—2)) 牛皮的线性 基数、桶、箱、计数 啥是稳定： 稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面。不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面。 哪些稳定： 稳定：冒泡、插入、归并和基数。 不稳定：选择、快速、希尔、堆。 排序算法大纲 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/1.bubbleSort.html":{"url":"sort/1.bubbleSort.html","title":"冒泡排序","keywords":"","body":"冒泡排序 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 1. 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 2. 动图演示 3. 最慢和最快 正序时最快，反序时最慢 4. JavaScript 代码实现 function bubbleSort(arr) { var len = arr.length; for (var i = 0; i arr[j+1]) { // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } 5. Python 代码实现 def bubbleSort(arr): for i in range(1, len(arr)): for j in range(0, len(arr)-i): if arr[j] > arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr 6. Go 代码实现 func bubbleSort(arr []int) []int { length := len(arr) for i := 0; i arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } return arr } 7. Java 代码实现 public class BubbleSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; } } if (flag) { break; } } return arr; } } 8. PHP 代码实现 function bubbleSort($arr) { $len = count($arr); for ($i = 0; $i $arr[$j+1]) { $tmp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $tmp; } } } return $arr; } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/2.selectionSort.html":{"url":"sort/2.selectionSort.html","title":"选择排序","keywords":"","body":"选择排序 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 1. 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2. 动图演示 3. JavaScript 代码实现 function selectionSort(arr) { var len = arr.length; var minIndex, temp; for (var i = 0; i 4. Python 代码实现 def selectionSort(arr): for i in range(len(arr) - 1): # 记录最小数的索引 minIndex = i for j in range(i + 1, len(arr)): if arr[j] 5. Go 代码实现 func selectionSort(arr []int) []int { length := len(arr) for i := 0; i arr[j] { min = j } } arr[i], arr[min] = arr[min], arr[i] } return arr } 6. Java 代码实现 public class SelectionSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i 7. PHP 代码实现 function selectionSort($arr) { $len = count($arr); for ($i = 0; $i 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/3.insertionSort.html":{"url":"sort/3.insertionSort.html","title":"插入排序","keywords":"","body":"插入排序 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 1. 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 2. 动图演示 3. JavaScript 代码实现 function insertionSort(arr) { var len = arr.length; var preIndex, current; for (var i = 1; i = 0 && arr[preIndex] > current) { arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr; } 4. Python 代码实现 def insertionSort(arr): for i in range(len(arr)): preIndex = i-1 current = arr[i] while preIndex >= 0 and arr[preIndex] > current: arr[preIndex+1] = arr[preIndex] preIndex-=1 arr[preIndex+1] = current return arr 5. Go 代码实现 func insertionSort(arr []int) []int { for i := range arr { preIndex := i - 1 current := arr[i] for preIndex >= 0 && arr[preIndex] > current { arr[preIndex+1] = arr[preIndex] preIndex -= 1 } arr[preIndex+1] = current } return arr } 6. Java 代码实现 public class InsertSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i 0 && tmp 7. PHP 代码实现 function insertionSort($arr) { $len = count($arr); for ($i = 1; $i = 0 && $arr[$preIndex] > $current) { $arr[$preIndex+1] = $arr[$preIndex]; $preIndex--; } $arr[$preIndex+1] = $current; } return $arr; } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/4.shellSort.html":{"url":"sort/4.shellSort.html","title":"希尔排序","keywords":"","body":"希尔排序 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 1. 算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 2. JavaScript 代码实现 function shellSort(arr) { var len = arr.length, temp, gap = 1; while(gap 0; gap = Math.floor(gap/3)) { for (var i = gap; i = 0 && arr[j] > temp; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } return arr; } 3. Python 代码实现 def shellSort(arr): import math gap=1 while(gap 0: for i in range(gap,len(arr)): temp = arr[i] j = i-gap while j >=0 and arr[j] > temp: arr[j+gap]=arr[j] j-=gap arr[j+gap] = temp gap = math.floor(gap/3) return arr } 4. Go 代码实现 func shellSort(arr []int) []int { length := len(arr) gap := 1 for gap 0 { for i := gap; i = 0 && arr[j] > temp { arr[j+gap] = arr[j] j -= gap } arr[j+gap] = temp } gap = gap / 3 } return arr } 5. Java 代码实现 public class ShellSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap 0) { for (int i = gap; i = 0 && arr[j] > tmp) { arr[j + gap] = arr[j]; j -= gap; } arr[j + gap] = tmp; } gap = (int) Math.floor(gap / 3); } return arr; } } 6. PHP 代码实现 function shellSort($arr) { $len = count($arr); $temp = 0; $gap = 1; while($gap 0; $gap = floor($gap / 3)) { for ($i = $gap; $i = 0 && $arr[$j] > $temp; $j -= $gap) { $arr[$j+$gap] = $arr[$j]; } $arr[$j+$gap] = $temp; } } return $arr; } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 16:21:32 "},"sort/5.mergeSort.html":{"url":"sort/5.mergeSort.html","title":"归并排序","keywords":"","body":"归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 2. 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 3. 动图演示 4. JavaScript 代码实现 function mergeSort(arr) { // 采用自上而下的递归方法 var len = arr.length; if(len 5. Python 代码实现 def mergeSort(arr): import math if(len(arr) 6. Go 代码实现 func mergeSort(arr []int) []int { length := len(arr) if length 7. Java 代码实现 public class MergeSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length 0 && right.length > 0) { if (left[0] 0) { result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); } while (right.length > 0) { result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); } return result; } } 8. PHP 代码实现 function mergeSort($arr) { $len = count($arr); if ($len 0 && count($right) > 0) { if ($left[0] 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/6.quickSort.html":{"url":"sort/6.quickSort.html","title":"快速排序","keywords":"","body":"快速排序 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 1. 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 2. 动图演示 3. JavaScript 代码实现 function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left pivot) { --high; } arr[low] = arr[high]; while (low 4. Python 代码实现 def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left 5. Go 代码实现 func quickSort(arr []int) []int { return _quickSort(arr, 0, len(arr)-1) } func _quickSort(arr []int, left, right int) []int { if left 6. C++版 //严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) { int pivot = A[low]; while (low = pivot) { --high; } A[low] = A[high]; while (low 7. Java 代码实现 public class QuickSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); } private int[] quickSort(int[] arr, int left, int right) { if (left 8. PHP 代码实现 function quickSort($arr) { if (count($arr) $middle) $rightArray[] = $arr[$i]; else $leftArray[] = $arr[$i]; } $leftArray = quickSort($leftArray); $leftArray[] = $middle; $rightArray = quickSort($rightArray); return array_merge($leftArray, $rightArray); } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/7.heapSort.html":{"url":"sort/7.heapSort.html","title":"堆排序","keywords":"","body":"堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 1. 算法步骤 将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 2. 动图演示 3. JavaScript 代码实现 var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i >= 0; i--) { heapify(arr, i); } } function heapify(arr, i) { // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left arr[largest]) { largest = left; } if (right arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest); } } function swap(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } function heapSort(arr) { buildMaxHeap(arr); for (var i = arr.length-1; i > 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0); } return arr; } 4. Python 代码实现 def buildMaxHeap(arr): import math for i in range(math.floor(len(arr)/2),-1,-1): heapify(arr,i) def heapify(arr, i): left = 2*i+1 right = 2*i+2 largest = i if left arr[largest]: largest = left if right arr[largest]: largest = right if largest != i: swap(arr, i, largest) heapify(arr, largest) def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] def heapSort(arr): global arrLen arrLen = len(arr) buildMaxHeap(arr) for i in range(len(arr)-1,0,-1): swap(arr,0,i) arrLen -=1 heapify(arr, 0) return arr 5. Go 代码实现 func heapSort(arr []int) []int { arrLen := len(arr) buildMaxHeap(arr, arrLen) for i := arrLen - 1; i >= 0; i-- { swap(arr, 0, i) arrLen -= 1 heapify(arr, 0, arrLen) } return arr } func buildMaxHeap(arr []int, arrLen int) { for i := arrLen / 2; i >= 0; i-- { heapify(arr, i, arrLen) } } func heapify(arr []int, i, arrLen int) { left := 2*i + 1 right := 2*i + 2 largest := i if left arr[largest] { largest = left } if right arr[largest] { largest = right } if largest != i { swap(arr, i, largest) heapify(arr, largest, arrLen) } } func swap(arr []int, i, j int) { arr[i], arr[j] = arr[j], arr[i] } 6. Java 代码实现 public class HeapSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i > 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0, len); } return arr; } private void buildMaxHeap(int[] arr, int len) { for (int i = (int) Math.floor(len / 2); i >= 0; i--) { heapify(arr, i, len); } } private void heapify(int[] arr, int i, int len) { int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left arr[largest]) { largest = left; } if (right arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest, len); } } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 7. PHP 代码实现 function buildMaxHeap(&$arr) { global $len; for ($i = floor($len/2); $i >= 0; $i--) { heapify($arr, $i); } } function heapify(&$arr, $i) { global $len; $left = 2 * $i + 1; $right = 2 * $i + 2; $largest = $i; if ($left $arr[$largest]) { $largest = $left; } if ($right $arr[$largest]) { $largest = $right; } if ($largest != $i) { swap($arr, $i, $largest); heapify($arr, $largest); } } function swap(&$arr, $i, $j) { $temp = $arr[$i]; $arr[$i] = $arr[$j]; $arr[$j] = $temp; } function heapSort($arr) { global $len; $len = count($arr); buildMaxHeap($arr); for ($i = count($arr) - 1; $i > 0; $i--) { swap($arr, 0, $i); $len--; heapify($arr, 0); } return $arr; } 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/8.countingSort.html":{"url":"sort/8.countingSort.html","title":"计数排序","keywords":"","body":"计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 1. 算法步骤 找出原数组中元素值最大的，记为max。 创建一个新数组count，其长度是max加1，其元素默认值都为0。 遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值。 创建结果数组result，起始索引index。 遍历count数组，找出其中元素值大于0的元素，将其对应的索引作为元素值填充到result数组中去，每处理一次，count中的该元素值减1，直到该元素值不大于0，依次处理count中剩下的元素。 返回结果数组result。 2. 动图演示 3. JavaScript 代码实现 function countingSort(arr, maxValue) { var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } 4. Python 代码实现 def countingSort(arr, maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 for j in range(bucketLen): while bucket[j]>0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr 5. Go 代码实现 func countingSort(arr []int, maxValue int) []int { bucketLen := maxValue + 1 bucket := make([]int, bucketLen) // 初始为0的数组 sortedIndex := 0 length := len(arr) for i := 0; i 0 { arr[sortedIndex] = j sortedIndex += 1 bucket[j] -= 1 } } return arr } 6. Java 代码实现 public class CountingSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); } private int[] countingSort(int[] arr, int maxValue) { int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) { bucket[value]++; } int sortedIndex = 0; for (int j = 0; j 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue 7. PHP 代码实现 function countingSort($arr, $maxValue = null) { if ($maxValue === null) { $maxValue = max($arr); } for ($m = 0; $m $len) { if($len !== null){ for($j = 0; $j 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/9.bucketSort.html":{"url":"sort/9.bucketSort.html","title":"桶排序","keywords":"","body":"桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 1. 什么时候最快 当输入的数据可以均匀的分配到每一个桶中。 2. 什么时候最慢 当输入的数据被分配到了同一个桶中。 3. 动图演示 4. JavaScript 代码实现 function bucketSort(arr, bucketSize) { if (arr.length === 0) { return arr; } var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i maxValue) { maxValue = arr[i]; // 输入数据的最大值 } } //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i 5. Java 代码实现 public class BucketSort implements IArraySort { private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); } private int[] bucketSort(int[] arr, int bucketSize) throws Exception { if (arr.length == 0) { return arr; } int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) { if (value maxValue) { maxValue = value; } } int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i 6. PHP 代码实现 function bucketSort($arr, $bucketSize = 5) { if (count($arr) === 0) { return $arr; } $minValue = $arr[0]; $maxValue = $arr[0]; for ($i = 1; $i $maxValue) { $maxValue = $arr[$i]; } } $bucketCount = floor(($maxValue - $minValue) / $bucketSize) + 1; $buckets = array(); for ($i = 0; $i 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "},"sort/10.radixSort.html":{"url":"sort/10.radixSort.html","title":"基数排序","keywords":"","body":"基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 1. 基数排序 vs 计数排序 vs 桶排序 基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； 2. LSD 基数排序动图演示 3. JavaScript 代码实现 //LSD Radix Sort var counter = []; function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; for (var i = 0; i 4. python 代码实现 def radix(arr): digit = 0 max_digit = 1 max_value = max(arr) #找出列表中最大的位数 while 10**max_digit 5. Java 代码实现 /** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */ public class RadixSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); } /** * 获取最高位数 */ private int getMaxDigit(int[] arr) { int maxValue = getMaxValue(arr); return getNumLenght(maxValue); } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue 6. PHP 代码实现 function radixSort($arr, $maxDigit = null) { if ($maxDigit === null) { $maxDigit = max($arr); } $counter = []; for ($i = 0; $i 本文出现所有代码均在 leetcode 测试通过!有兴趣可进下方刷题群一起交流！群里可BAT内推修订时间: 2020-06-08 10:36:41 "}}